<!DOCTYPE html>


<html lang="zh-Fans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="记录生活点滴" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Interview questions |  我的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/header.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Interview-questions"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Interview questions
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/25/Interview-questions/" class="article-date">
  <time datetime="2022-06-25T12:38:09.000Z" itemprop="datePublished">2022-06-25</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">22.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">82 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="面试题目录"><a href="#面试题目录" class="headerlink" title="面试题目录"></a>面试题目录</h1><h3 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h3><p>每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对 象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个 属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我 们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.<strong>proto</strong><br>特点： JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于 自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript 引擎会先看当前对象中是否有这个属性， 如果 没有的话，就会查找他的 Prototype 对象是否有这个属性，如此递推下去，一直检索 到 Object 内建对象</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Undefined、Null、Boolean、Number、String</p>
<h3 id="js内置对象"><a href="#js内置对象" class="headerlink" title="js内置对象"></a>js内置对象</h3><p>Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<h3 id="Js有几种类型的值以及存储的位置"><a href="#Js有几种类型的值以及存储的位置" class="headerlink" title="Js有几种类型的值以及存储的位置"></a>Js有几种类型的值以及存储的位置</h3><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 43<br>44 1，原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属 于被频繁使用数据，所以放入栈中存储； 2，引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈 中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该 实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后 从堆中获得实体</p>
<h3 id="Js继承的几种方式"><a href="#Js继承的几种方式" class="headerlink" title="Js继承的几种方式"></a>Js继承的几种方式</h3><p>1，构造函数继承，使用 call 和 apply 两个方法的特性可以实现，改变方法中的 this 2，原型链继承 3，组合式继承<br>组合继承，指的是将原型链和借用构造函数的技术组合到一起。思路是使用原型链实 现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过 在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性。<br>45 instance2.sayAge(); //25 这个例子中，两个实例既分别拥有自己的属性，包括 colors 属性，又可以使用相同的 方法。 组合继承避免了原型链和借用构造函数的缺点，融合了他们的优点，是 JavaScript 中最常用的继承模式。</p>
<h3 id="Js创建对象的几种方式"><a href="#Js创建对象的几种方式" class="headerlink" title="Js创建对象的几种方式"></a>Js创建对象的几种方式</h3><p>javascript 创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以 用 JSON；但写法有很多种，也能混合使用<br>1、对象字面量的方 式 person={firstname:”Mark”,lastname:”Yun”,age:25,eyecolor:”black”};<br>2、用 function 来模拟无参的构造函数<br>3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）<br>4、用工厂方式来创建（内置对象）<br>5、用原型方式来创建<br>5、用混合方式来创建</p>
<h3 id="Js的作用域链"><a href="#Js的作用域链" class="headerlink" title="Js的作用域链"></a>Js的作用域链</h3><p>首先在 js 中有作用域的概念，值得就是一个变量的活动范围，分为全局作用域和局部 作用域，全局作用域指的是 window，局部作用域指的是每一个函数内部，在作用域 中查找一个变量首先在自己当前作用域查找找不到向上级查找，逐层向上找到 window 为止，找不到就会抛出一个错误，这个查找的过程就叫作用域链，作用域链 的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上 访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。作 用域链有一个需要要注意的问题就是变量提升，当一个变量的使用在定义之前的时候就会得到一个 undefined 值，在 es6 中则不会出现这个问题，es6 不允许在定义之前 使用</p>
<h3 id="this的理解"><a href="#this的理解" class="headerlink" title="this的理解"></a>this的理解</h3><p>this 分为几个不同的使用场景，在 function 中 this 指的的是 window，如果是实用 new 调用的话 this 指的是当前的实例化对象，在事件调用函数中 this 指的调用事件 的 window 特殊的是在 IE 中的 attachEvent 中的 this 总是指向全局对象 Window；，在定时器中 this 指的是 window，在 es6 中有一个箭头函数，在箭头函 数中 this 永远指向的是父级对象<br>1.当函数作为对象的方法调用时，this 指向该对象。<br>2.当函数作为淡出函数调用时，this 指向全局对象（严格模式时，为 undefined）<br>3.构造函数中的 this 指向新创建的对象<br>4.嵌套函数中的 this 不会继承上层函数的 this，如果需要，可以用一个变量保存上层 函数的 this。</p>
<h3 id="什么事window对象，什么事document对象"><a href="#什么事window对象，什么事document对象" class="headerlink" title="什么事window对象，什么事document对象"></a>什么事window对象，什么事document对象</h3><p>window:它是一个顶层对象,而不是另一个对象的属性，即浏览器的窗口。<br>document:代表整个 HTML 文档,可用来访问页面中的所有元素<br>Window 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象。我们创建的所有对 象、函数、变量都是<br>Window 对象的成员Window 对象的方法和属性是在全局范围内有效的。<br>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属 性节点, 注释节点）<br>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问<br>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进 行访问</p>
<h3 id="事件是什么，如何阻止冒泡"><a href="#事件是什么，如何阻止冒泡" class="headerlink" title="事件是什么，如何阻止冒泡"></a>事件是什么，如何阻止冒泡</h3><ol>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮 就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li>
<li>事件处理机制：IE 是事件冒泡、Firefox 同时支持两种事件模型，也就是：捕获型 事件和冒泡型事件；</li>
<li>ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true;）</li>
</ol>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在 一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以 突破作用链域，将函数内部的变量和方法传递到外部。<br>闭包的特性： 1，函数内再嵌套函数 2，内部函数可以引用外层的参数和变量 3，参数和变量不会被垃圾回收机制回收 闭包的使用场景 常见的闭包的使用场景就是模块化，用来做模块内部的实现通过接口的扩展贡其他模 块使用 在就是闭包可以用来缓存值，减少不必要的技术，例如 vue 里面的计算属性</p>
<h3 id="如何判断对象是否属于类"><a href="#如何判断对象是否属于类" class="headerlink" title="如何判断对象是否属于类"></a>如何判断对象是否属于类</h3><p>1，使用 instanceof if(a instanceof Person){ alert(‘yes’); }</p>
<h3 id="Json的了解"><a href="#Json的了解" class="headerlink" title="Json的了解"></a>Json的了解</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于 JavaScript 的一个子集。数据格式简单, 易于读写, 占用带宽小 如：{“age”:”12”, “name”:”back”} JSON 字符串转换为 JSON 对象: var obj =eval(‘(‘+ str +’)’); var obj = str.parseJSON(); var obj = JSON.parse(str);<br>JSON 对象转换为 JSON 字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj);</p>
<h3 id="Dom操作"><a href="#Dom操作" class="headerlink" title="Dom操作"></a>Dom操作</h3><p>1）创建新节点<br>createDocumentFragment() //创建一个 DOM 片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>2）添加、移除、替换、插入 appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>3）查找 getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的 Name 属性的值(IE 容错能力较强，会得到一 个数组，其中包括 id 等于 name 值的) getElementById() //通过元素 Id，唯一性</p>
<h3 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="headerlink" title="bind、call、apply的区别"></a>bind、call、apply的区别</h3><p>在说区别之前还是先总结一下三者的相似之处： 1、都是用来改变函数的 this 对象的指向的。 2、第一个参数都是 this 要指向的对象。 3、都可以利用后续参数传参。<br>关于 call() 和 apply()我的理解就是，它们的作用是： 让函数在某个指定的对象下执 行。<br>call() 和 apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行 上下文。<br>call()和 apply()的区别就在于，两者之间的参数。<br>call()在第一个参数之后的 后续所有参数就是传入该函数的值。<br>apply() 只有两个 参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。<br>bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会 立即执行，而前两者是直接执行该函数。他的参数和 call()相同。</p>
<h3 id="数组和对象的原生方法"><a href="#数组和对象的原生方法" class="headerlink" title="数组和对象的原生方法"></a>数组和对象的原生方法</h3><h3 id="字符串的原生方法"><a href="#字符串的原生方法" class="headerlink" title="字符串的原生方法"></a>字符串的原生方法</h3><h3 id="那些操作会内存泄漏"><a href="#那些操作会内存泄漏" class="headerlink" title="那些操作会内存泄漏"></a>那些操作会内存泄漏</h3><p>1，使用闭包的时候如果在闭包变量中保存了大量的 dom 结构而且不去使用长期存在 的时候<br>2，内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>3，垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个 对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环 的，那么该对象的内存即可回收。<br>4，setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>5，闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循 环）</p>
<h3 id="页面重构怎么操作"><a href="#页面重构怎么操作" class="headerlink" title="页面重构怎么操作"></a>页面重构怎么操作</h3><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持 一致的行为。 也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。<br>对于传统的网站来说重构通常是：表格(table)布局改为 DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的 CSS、如对 IE6 有效的) 对于移动平台的优化 针对于 SEO 进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的 API 代替旧有的框架、语言(如 VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩 JS、CSS、image 等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用 CDN 来加速资源加载 对于 JS DOM 的优化 HTTP 服务器的文件缓存</p>
<h3 id="IE和其他浏览器的区别"><a href="#IE和其他浏览器的区别" class="headerlink" title="IE和其他浏览器的区别"></a>IE和其他浏览器的区别</h3><p>1、事件不同之处：<br>1-1，触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对 象的 srcElement 属性；<br>1-2，获取字符代码、如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要 获取字符代码，需要使用 charCode 属性；<br>1-3，阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须 将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；<br>1-4，停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用stopPropagation()；</p>
<h3 id="公钥加密和死要加密"><a href="#公钥加密和死要加密" class="headerlink" title="公钥加密和死要加密"></a>公钥加密和死要加密</h3><p>一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证; HTTP 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</p>
<h3 id="Node的优缺点"><a href="#Node的优缺点" class="headerlink" title="Node的优缺点"></a>Node的优缺点</h3><p>优点）因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因 此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得 多。此外，与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，因此 客户端和服务器端都用同一种语言编写，这是非常美妙的事情。<br>缺点）Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺 少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。</p>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>事件代理的原理其实就和作用域链的原理差不多，但是事件代理是利用事件的冒泡原 理来实现的，事件代理就是通过给祖先元素添加事件，通过事件目标对象开始向上查 找找到匹配的子节点为止，如果找不到则到绑定事件的那个祖先元素为止，找到了就 触发事件，并且可以通过 js 中 call 和 apply 来改变触发事件函数中的 this 为当前绑 定节点，也是通过一层一层逐层向上的方式进行匹配查找而触发对应事件，好处就是 可以使后添加的 dom 元素也同样有之前存在元素的事件，jquery 中可以使用 on， delegate，live 实现的，不过在 jquery1.7 版本以后吧 live 给废除了，原因就是 live 绑定事件的祖先元素是整个 html 页面的根节点，所以性能消耗比较大，在后边的版 本中给删除了，使用 on，delegate 代替<br>优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上<br>缺点： 使用不当会造成事件在不应该触发时触发</p>
<h3 id="Js垃圾回收"><a href="#Js垃圾回收" class="headerlink" title="Js垃圾回收"></a>Js垃圾回收</h3><p>标记清除（mark and sweep）<br>这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如 函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候 （函数执行结束）将其标记为“离开环境”。<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环 境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的 就是要删除的变量了<br>引用计数(reference counting)<br>在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式 进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量 并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变 成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明 没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回 收器会在运行的时候清理掉引用次数为 0 的值占用的空间。<br>在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过引用计数回收垃圾的， 也就是说只要涉及 BOM 及 DOM 就会出 现循环引用问题。</p>
<h3 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h3><p>严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] eval 不会在它的外层作用域引入变量 eval 和 arguments 不能被重新赋值 arguments 不会自动反映函数参数的变化 不能使用 arguments.callee 不能使用 arguments.caller 禁止 this 指向全局对象 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 增加了保留字（比如 protected、static 和 interface）<br>设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 注：经过测试 IE6,7,8,9 均不支持严格模式。</p>
<h3 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h3><p>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘<br>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产 生重绘回流<br>注意：JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流</p>
<h3 id="script的位置是否会影响首屏幕显示时间"><a href="#script的位置是否会影响首屏幕显示时间" class="headerlink" title="script的位置是否会影响首屏幕显示时间"></a>script的位置是否会影响首屏幕显示时间</h3><p>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script 的位置不影响首屏显示的开始时间。<br>浏览器解析 HTML 是自上而下的线性过程，script 作为 HTML 的一部分同样遵循这 个原则<br>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏 显示的完成时间</p>
<h3 id="Dom事件"><a href="#Dom事件" class="headerlink" title="Dom事件"></a>Dom事件</h3><p>DOM0 级事件处理方式： btn.onclick = func; btn.onclick = null;<br>DOM2 级事件处理方式：<br>btn.addEventListener(‘click’, func, false);<br>btn.removeEventListener(‘click’, func, false);<br>btn.attachEvent(“onclick”, func);<br>btn.detachEvent(“onclick”, func);<br>DOM3 级事件处理方式：<br>eventUtil.addListener(input, “textInput”, func);<br>eventUtil 是自定义对象，textInput 是 DOM3 级事件</p>
<h3 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h3><p>捕获、目标、冒泡<br>按照 W3C 标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段<br>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数<br>注意 1：前提是事件被确实触发<br>注意 2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”<br>事件执行顺序：判断的关键是否目标元素<br>非目标元素：根据 W3C 的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）<br>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）<br>最终顺序：父元素捕获-&gt;目标元素事件 1-&gt;目标元素事件 2-&gt;子元素捕获-&gt;子元素冒 泡-&gt;父元素冒泡<br>65注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有 嵌套关系 在一个 DOM 上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几 次，先执行冒泡还是捕获？ 该 DOM 上的事件如果被触发，会执行两次（执行次数等于绑定次数）<br>如果该 DOM 是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获<br>如果该 DOM 是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数<br>执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔<br>（否则拖拽类的节流都将无连续效果）<br>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件<br>函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让<br>这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就<br>clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。<br>函数节流简单实现：<br>function throttle(method, context) {<br>clearTimeout(methor.tId);<br>method.tId = setTimeout(function(){<br>method.call(context);<br>}， 100); // 两次调用至少间隔 100ms<br>}Ï<br>// 调用<br>window.onresize = function(){<br>throttle(myFunc, window);<br>}</p>
<h3 id="New都干了什么"><a href="#New都干了什么" class="headerlink" title="New都干了什么"></a>New都干了什么</h3><p>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型<br>属性和方法被加入到 this 引用的对象中<br>新创建的对象由 this 所引用，并且最后隐式的返回 this</p>
<h3 id="Js异步的方法"><a href="#Js异步的方法" class="headerlink" title="Js异步的方法"></a>Js异步的方法</h3><p>回调函数<br>事件监听<br>发布/订阅<br>Promises 对象<br>Async 函数[ES7]</p>
<h3 id="Js数组重排的算法"><a href="#Js数组重排的算法" class="headerlink" title="Js数组重排的算法"></a>Js数组重排的算法</h3><p>1，快速排序<br>从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然 后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分 别给两边递归，设置好出口<br>2，插入排序<br>思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经 排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面<br>3，冒泡排序<br>故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对<br>4，选择排序<br>将当前未确定块的 min 或者 max 取出来插到最前面或者后面</p>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比<br>如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再<br>将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载<br>图片预加载是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用<br>户体验。常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一<br>种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。相关<br>代码如下：<br>CSS 预加载图片方式：</p>
<p> preload-01 { background: url(<a target="_blank" rel="noopener" href="http://domain.tld/image-01.png">http://domain.tld/image-01.png</a>) no-repeat -</p>
<p>9999px -9999px; }</p>
<p>preload-02 { background: url(<a target="_blank" rel="noopener" href="http://domain.tld/image-02.png">http://domain.tld/image-02.png</a>) no-repeat -</p>
<p>9999px -9999px; }</p>
<p> preload-03 { background: url(<a target="_blank" rel="noopener" href="http://domain.tld/image-03.png">http://domain.tld/image-03.png</a>) no-repeat -</p>
<p>9999px -9999px; }<br>Javascript 预加载图片的方式：<br>function preloadImg(url) {<br>var img = new Image();<br>img.src = url;<br>if(img.complete) {<br>//接下来可以使用图片了<br>//do something here<br>} else {<br>img.onload = function() {<br>//接下来可以使用图片了<br>//do something here<br>};<br>}<br>}</p>
<h3 id="AMD和COM的区别"><a href="#AMD和COM的区别" class="headerlink" title="AMD和COM的区别"></a>AMD和COM的区别</h3><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开 始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有<br>全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>
<h3 id="ES6常用特性"><a href="#ES6常用特性" class="headerlink" title="ES6常用特性"></a>ES6常用特性</h3><p>变量定义(let 和 const,可变与不可变，const 定义对象的特殊情况)<br>解构赋值<br>模板字符串<br>数组新 API(例：Array.from(),entries(),values(),keys())<br>箭头函数(rest 参数，扩展运算符，::绑定 this)<br>Set 和 Map 数据结构(set 实例成员值唯一存储 key 值，map 实例存储键值对(key- value))<br>Promise 对象(前端异步解决方案进化史，generator 函数，async 函数)<br>Class 语法糖(super 关键字)</p>
<h3 id="对ES6的理解"><a href="#对ES6的理解" class="headerlink" title="对ES6的理解"></a>对ES6的理解</h3><p>语法糖(箭头函数，类的定义，继承)，以及一些新的扩展（数组，字符串，对象，方 法等），对作用域的重新定义，以及异步编程的解决方案（promise，async，<br>await）、解构赋值的出现<br>1 块级作用域绑定<br>2 字符串和正则表达式<br>3 函数<br>4 扩展对象的功能性<br>5 解构：使数据访问更便捷<br>6 Symbol 和 Symbol 属性<br>7 Set 集合与 Map 集合<br>8 迭代器（Iterator）和生成器（Generator）<br>9 JavaScript 中的类<br>10 改进数组的功能<br>11 Promise 与异步编程<br>12 代理（Proxy)和反射（Peflection）<br>13 用模块封装代码</p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>一个程序至少有一个进程,一个进程至少有一个线程;<br>多进程拥有独立的内存,多线程共享内存,所以多线程提高了运行效率;<br>多线程的重要意义在于一个应用程序中,有多个执行程序能够同时执行,但是系统并没有将多线程看成多个独立的应用</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>拷贝其实就是对象复制，为了解决对象复制是产生的引用类型问题<br>浅拷贝：利用迭代器，循环对象将对象中的所有可枚举属性复制到另一个对象上，但 是浅拷贝的有一个问题就是只是拷贝了对象的一级，其他级还如果是引用类型的值的 话依旧解决不了<br>深拷贝：深拷贝解决了浅拷贝的问题，利用递归的形势便利对象的每一级，实现起来较为复杂，得判断值是数组还是对象；<br>总结<br>浅拷贝:只是增加了一个指针，指向已存在对象的内存。<br>深拷贝:是增加了一个指针，并新开辟了一块空间，让指针指向这块新开辟的空 间。<br>浅拷贝:在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误</p>
<h3 id="区分数组和对象的方法"><a href="#区分数组和对象的方法" class="headerlink" title="区分数组和对象的方法"></a>区分数组和对象的方法</h3><p>1、从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用 isPrototypeOf()方法，判定 Array 是不是在 obj 的原型链中，如果是，则返回 true,否则 false。<br>Array.prototype.isPrototype([]) //true<br>2、也可以从构造函数入手，利用对向的 constructor 属性<br>3、根据对象的 class 属性(类属性)，跨原型链调用 toString()方法。<br>使用 call 方法让 obj 对象使用 Object 原型里的 toString() 方法<br>Object.prototype.toString.call(Window);<br>4、Array.isArray()方法。</p>
<h3 id="Promise的理解"><a href="#Promise的理解" class="headerlink" title="Promise的理解"></a>Promise的理解</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听— —更合理和更强大。<br>Promise 有三种状态：pending（进行中）、fulfilled（已成 功）和 rejected（已失败）。<br>但是无法获取到 pending 状态，在 promise 中接受两 个内置参数分别是 resolve（成功）和 reject（失败），Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。<br>then 方法可以 传递两个回调函数第一个是成功，第二个是失败，失败回调也可以使用 promise 的 catch 方法回调，promise 还有一个强大的功能那就是 all 方法可以组合多个 promise 实例，包装成一个新的 Promise 实例</p>
<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对 象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。async / await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案。 目前 async / await 在 IE edge 中已经可以直接使用了，但是 chrome 和 Node.js 还 没有支持。幸运的是，babel 已经支持 async 的 transform 了，所以我们使用的时候引入 babel 就行。在开始之前我们需要引入以下的 package，preset-stage-3 里就有我们需要的 async/await 的编译文件。</p>
<h3 id="箭头函数和普通函数的作用域上下文的区别对ES6的理解"><a href="#箭头函数和普通函数的作用域上下文的区别对ES6的理解" class="headerlink" title="箭头函数和普通函数的作用域上下文的区别对ES6的理解"></a>箭头函数和普通函数的作用域上下文的区别对ES6的理解</h3><p>箭头函数其实只是一个密名函数的语法糖，区别在于普通函数作用域中的 this 有特定 的指向，一般指向 window，而箭头函数中的 this 只有一个指向那就是指当前函数所 在的对象，其实现原理其实就是类似于之前编程的时候在函数外围定义 that 一样，用了箭头函数就不用定义 that 了直接使用 this</p>
<h3 id="ES6如何转成ES5对ES6的理解"><a href="#ES6如何转成ES5对ES6的理解" class="headerlink" title="ES6如何转成ES5对ES6的理解"></a>ES6如何转成ES5对ES6的理解</h3><p>ECMAScript 6(ES6)的发展速度非常之快，但现代浏览器对 ES6 新特性支持度不 高，所以要想在浏览器中直接使用 ES6 的新特性就得借助别的工具来实现。 Babel 是一个广泛使用的转码器，babel 可以将 ES6 代码完美地转换为 ES5 代码， 所以我们不用等到浏览器的支持就可以在项目中使用 ES6 的特性。<br>babel 6 与之前版本的区别：<br>之前版本只要安装一个 babel 就可以用了，所以之前的版本包含了一大堆的东西，这 也导致了下载一堆不必要的东西。但在 babel 6 中，将 babel 拆分成两个包： babel-cli 和 babel-core。如果你想要在 CLI(终端或 REPL)使用 babel 就下载 babel-cli，如果想要在 node 中使用就下载 babel-core。 babel 6 已结尽可能的模 块化了，如果还用 babel 6 之前的方法转换 ES6，它会原样输出，并不会转化，因为 需要安装插件。如果你想使用箭头函数，那就得安装箭头函数插件 npm install<br>babel-plugin-transform-es2015-arrow-functions。</p>
<h3 id="一个页面从输入URL到加载完成的过程"><a href="#一个页面从输入URL到加载完成的过程" class="headerlink" title="一个页面从输入URL到加载完成的过程"></a>一个页面从输入URL到加载完成的过程</h3><p>详细版：<br>1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协<br>议就按照 Web 方式来处理;<br>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>3、通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求;<br>4、进行 HTTP 协议会话，客户端发送报头(请求报头);<br>5、进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS<br>等服务器;<br>6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到<br>对应的请求处理;<br>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服<br>务器最后修改时间对比，一致则返回 304;<br>8、浏览器开始下载 html 文档(响应报头，状态码 200)，同时使用缓存;<br>9、文档树建立，根据标记请求所需指定 MIME 类型的文件（比如 css、<br>js）, 同时设置了 cookie;<br>10、页面开始渲染 DOM，JS 根据 DOM API 操作 DOM,执行事件绑定等，<br>页面显示完成。<br>简洁版：<br>浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请<br>求；<br>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、<br>图象等）；<br>浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内<br>部数据结构（如 HTML 的 DOM）；<br>载入解析到的资源文件，渲染页面，完成。</p>
<h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><p>优化原则和方向<br>性能优化的原则是以更好的用户体验为标准，具体就是实现下面的目标：<br>多使用内存、缓存或者其他方法<br>减少 CPU 和GPU 计算，更快展现<br>优化的方向有两个：<br>减少页面体积，提升网络加载<br>优化页面渲染<br>减少页面体积，提升网络加载<br>静态资源的压缩合并（<br>JS 代码压缩合并、CSS 代码压缩合并、雪碧图）<br>静态资源缓存（资源名称加 MD5 戳）<br>使用 CDN 让资源加载更快<br>优化页面渲染<br>CSS 放前面，JS 放后面<br>懒加载（图片懒加载、下拉加载更多）<br>减少DOM 查询，对 DOM 查询做缓存<br>减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）<br>事件节流<br>尽早执行操作（DOMContentLoaded）<br>使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面<br>HTML 的时间</p>
<h3 id="React和vue的区别"><a href="#React和vue的区别" class="headerlink" title="React和vue的区别"></a>React和vue的区别</h3><p>1.首先 react 和 vue 一样都是前端 spa 应用框架，他们的区别就是，<br>2.组件的创建不一样<br>3.react 使用 class 和 函数创建组件 （只有局部）<br>4.而 vue 则使用的 vue 实例的 components 方法和 components 属性(有局部和全局一说)<br>5.在 react 中没有指令，计算属性，watch 监听，computed，这些内<br>容<br>6.在 react 组件中，只有几个概念，生命周期，state，props，合成事<br>件，<br>7.在 vue 中可以使用 v-model 完成 控件和属性值的同步（双向的数据绑定），而在 react 并没与指令的概念，所以使用受控组件代替<br>8.在 vue 中使用 get，set 拦截器，处理数据的绑定，而 react 则使用的是 setState 手动触发</p>
<h3 id="路由原理（hash、history）"><a href="#路由原理（hash、history）" class="headerlink" title="路由原理（hash、history）"></a>路由原理（hash、history）</h3><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相 应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式<br> Hash 模式<br> History 模式<br>Hash 模式<br><a target="_blank" rel="noopener" href="http://www.test.com/#/">www.test.com/#/</a> 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何<br>变化，服务端接收到的 URL 请求永远是 <a target="_blank" rel="noopener" href="http://www.test.com./">www.test.com。</a><br>window.addEventListener(‘hashchange’, () =&gt; {<br>// … 具体逻辑<br>})<br>Hash 模式相对来说更简单，并且兼容性也更好。</p>
<p>History 模式<br>History 模式是 HTML5 新推出的功能，主要使<br>用 history.pushState 和 history.replaceState 改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。<br>// 新增历史记录<br>history.pushState(stateObject, title, URL)<br>// 替换当前历史记录<br>history.replaceState(stateObject, title, URL)<br>当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件<br>window.addEventListener(‘popstate’, e =&gt; {<br>// e.state 就是 pushState(stateObject) 中的 stateObject<br>console.log(e.state)<br>})</p>
<h3 id="React的基础"><a href="#React的基础" class="headerlink" title="React的基础"></a>React的基础</h3><p>要真正理解 React，开发者必须要明白这几点：</p>
<p>1.React 界面完全由数据驱动；<br>2.React 中一切都是组件；<br>3.props 是 React 组件之间通讯的基本方式。<br>好的，让我们开始吧！<br>界面完全由数据驱动<br>组件：（React 应用程序的组成）<br>单向数据流， 组件化开发， 虚拟 dom，JSX，只关注 MV的 v 这一 层，渲染性能好</p>
<h3 id="React的高级应用"><a href="#React的高级应用" class="headerlink" title="React的高级应用"></a>React的高级应用</h3><p>React 版本更新特性<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017321982">https://segmentfault.com/a/1190000017321982</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/c_kite/article/details/80303341">https://blog.csdn.net/c_kite/article/details/80303341</a><br><a target="_blank" rel="noopener" href="https://www.colabug.com/3873428.html">https://www.colabug.com/3873428.html</a><br>React 开发高级功能<br>装饰器模式<br>模块化 css<br>路由懒加载<br>dva 框架<br>React 开发规范<br><a target="_blank" rel="noopener" href="https://github.com/shimohq/react-cookbook">https://github.com/shimohq/react-cookbook</a><br>react 原理研究<br><a target="_blank" rel="noopener" href="https://github.com/hujiulong/blog">https://github.com/hujiulong/blog</a></p>
<h3 id="React的生命周期11个"><a href="#React的生命周期11个" class="headerlink" title="React的生命周期11个"></a>React的生命周期11个</h3><p>可以说他有 11 个，也可说他有 10 个<br>有 3 个阶段：实例化，存在期，销毁期<br>实例化阶段：props 的实例化， state 的实例化，<br>componentWillMount 渲染前（修改 state 的最后一次机会）<br>render（渲染）<br>componentDidMount（渲染后，首次可以访问到 dom）<br>在实例化阶段除了 render 生命周期外，其它的生命周期只会执行一次</p>
<p>存在期<br>componentWillReceiveProps 当 props 值发生变化就会执行<br> shouldComponentUpdate 可以用来确认组件的更新，通过返回布尔值来确定组件是否重新渲染<br>componentWillUpdate 更新前<br>render 更新<br>compoentDidUpdate 更新后</p>
<p>销毁期<br>componentWillUnmount 销毁</p>
<p>可以获取 dom 的生命周期<br>componentDidMount<br>componentWillReceiveProps （不能操作）<br>shouldComponentUpdate （不能操作）<br>componentWillUpdate （不能操作）<br>render （不能操作）<br>compoentDidUpdate<br>componentWillUnmount （不能操作）<br>只执行一次的生命周期<br>初始化阶段除了 render 之外所有的，销毁期的那个<br>可以修改 state 的生命周期<br>componentWillMount， componentDidMount,<br>componentWillReceiveProps,<br>shouldComponentUpdate, compoentDidUpdate<br>调用 setState 之后执行哪些生命周期<br>shouldComponentUpdate 如果返回 true 就会执行<br>ComponentWillUpdate<br>render<br>ComponentDidUpdate</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 的值可以是字符串，函数<br>如果是字符串，作用在 dom 元素上使用 refs 获取到的是对应 dom，<br>作用在组件上获取到的是组件实例，<br>ref 不能作用在函数式组件上，因为函数式组件没有实例，如果是函数，那么函数会接收到一个参数就是当前元素（dom，组件实例）<br>如果是函数的话会在 render 后执行，<br>如果是函数那么在组件销毁的时候也会执行，并且传入 null</p>
<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><p>通信场景，父子，子父，跨级，同级<br>父子，props<br>子父：props 传递回调函数，子组件执行传递参数， 使用 refs 获取子组件实例<br>跨级：使用 props 逐层传递， 利用 context 虫洞<br>同级：使用代理父组件获取另一个子组件的数据传递到另一个子组件redux</p>
<h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><p>首先合成事件的使用类似于 dom0 级事件，但是 dom0 级事件小写，react 合成事件驼峰，dom0 级事件传递字符串就可以执行，react 必须传递回调函数<br>回调函数的问题就是没有 this，获取不到组件实例，<br>可提前绑定 this，使用 bind，或者使用箭头函数的特性<br>如果使用 bind 那么 e 对象会传递到事件处理函数的最后一个参数</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>受控组件</p>
<p>其值由 React 控制的输入表单元素称为“受控组件”。 实现了 vue 框架中的 v-model<br>将表单的 vaule 值与 state 绑定，在表单元素上执行 onChange 事<br>件，同步 state和 value 的值非受控组件<br>如果让表单数据由 DOM 处理时，是非受控组件。<br>非受控组件使用 ref 将表单元素保存在对象属性中</p>
<h3 id="setState发生了什么"><a href="#setState发生了什么" class="headerlink" title="setState发生了什么"></a>setState发生了什么</h3><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。<br>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。<br>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。<br>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<h3 id="Element和Component的区别"><a href="#Element和Component的区别" class="headerlink" title="Element和Component的区别"></a>Element和Component的区别</h3><p>简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement 的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。更多介绍可以参考 React Elements vs React Components。</p>
<h3 id="Refs的作用"><a href="#Refs的作用" class="headerlink" title="Refs的作用"></a>Refs的作用</h3><p>this.refs.textInputRefs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。<br>我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：<br>class CustomForm extends Component {<br>handleSubmit = () =&gt; {<br>console.log(“Input Value: “, this.input.value)<br>}<br>render () {<br>return (</p>
<form onSubmit={this.handleSubmit}>
<input type='text' ref={(input) => this.input = input} />
<button type='submit'>Submit</button>
</form>
)
}
}
上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：
function CustomForm ({handleSubmit}) {
let inputElement
return (
<form onSubmit={() => handleSubmit(inputElement.value)}>
<input type='text' ref={(input) => inputElement = input} />
<button type='submit'>Submit</button></form>
)
}

<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>单向数据流，而 redux 在此基础上提出三个原则：<br>唯一数据源：在 redux 的应用中只能有一个 state 数据源；<br>保持状态只读:在 view 层只能对 state 数据进行读取，无法改变；<br>数据改变只能通过纯函数完成:reducer 函数只做数据的运算的不做数据的存储，<br>所有的 reducer 函数只会接受值，进行运算，redux 中的 reducer 接受两个参数，第一个参数是 state 当前的数据状态，第二个参数是 action 传入的值；将原始值和传入进行运算；<br>二、 理论讲解：<br>(一)<br>action:</p>
<ol>
<li>定义：Action 是把数据从应用（译者注：这里之所以不叫 view 是因为<br>这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传<br>到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通<br>过 store.dispatch() 将 action 传到 store。</li>
<li>action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作</li>
<li>redux 中的 action 和 flux 中的 action 的区别：<br>在 Redux 中的 action 创建函数只是简单的返回一个 action，redux<br>中 action 只需要将返回的对象传递给 reducer 函数去做处理；<br>在 传统的 Flux 实现中，当调用 action 创建函数时，一般会触发一个<br>dispatch<br>(二)<br>reducer:</li>
<li>state 的设计（应用数据库）<br>尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象<br>里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数<br>据。把应用的 state 想像成数据库</li>
<li>reducer 函数的设计：<br>保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数；<br>执行有副作用的操作，如 API 请求和路由跳转；<br>调用非纯函数，如 Date.now() 或 Math.random()。<br>注意：<br>在 reducer 中不要直接修改 state，。 使用 Object.assign() 新建了一<br>个副本。不能这样使 用 Object.assign(state, {visibilityFilter: action.filter })，因为<br>它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可<br>以开启对 ES7 提案对象展开运算符的支持, 从而使 用 { …state, …newState } 达到相同的目的。</li>
<li>对于 reducer 文件的拆分以及使用 combineReducers()工具类<br>随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中,<br>以保持其独立性并用于专门处理不同的数据域。每个 reducer 只负责<br>管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不<br>同，分别对应它管理的那部分 state 数据<br>注：combineReducers() 所做的只是生成一个函数，这个函数来调用你<br>的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中<br>的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果<br>合并成一个大的对象。<br>注：这里其实实现的就是类似于 vuex 中模块式管理数据逻辑层；<br>(三)<br>store:<br>维持应用的 state；<br>提供 getState() 方法获取 state；<br>提供 dispatch(action) 方法更新 state；<br>通过 subscribe(listener) 注册监听器;<br>通过 unsubscribe(listener) 返回的函数注销监听器<br>注：Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你<br>应该使用 reducer 组合而不是创建多个 store。<br>三、 react 与 redux 的搭配：<br>声明：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、<br>jQuery 甚至纯 JavaScript。<br>在 react 中使用 react，需要安装 react-redux；<br>npm install –save react-redux<br>容器组件：（顶层组件）<br>只在最顶层组件（如路由操作）里使用 Redux，数据的读取和更改都来自<br>redux；<br>展示组件：（傻瓜组件）<br>其余内部组件仅仅是展示性的，所有数据都通过 props 传入。数据的读取和修改来自于 props 的数据和 props 传递的回掉函数；<br>react 和 redux 的链接：<br>我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch<br>actions 以及从 Redux store 读取到 state。<br>首先，我们需要获取从之前安装好的 react-redux 提供的 Provider，并且在渲染<br>之前将根组件包装进 <Provider>。<br>接着，我们想要通过 react-redux 提供的 connect() 方法将包装好的组件连接到<br>Redux。尽量只做一个顶层的组件，或者 route 处理。从技术上来说你可以将应<br>用中的任何一个组件 connect() 到 Redux store 中，但尽量避免这么做，因为这<br>个数据流很难追踪。<br>任何一个从 connect() 包装好的组件都可以得到一个 dispatch 方法作为组件的 props，以及得到全局 state 中所需的任何内容。 connect() 的唯一参数<br>是 selector。此方法可以从 Redux store 接收到全局的 state，然后返回组件<br>中需要的 props。最简单的情况下，可以返回一个初始的 state （例如，返回认<br>证方法），但最好先将其进行转化。</li>
</ol>
<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>vue 的生命周期主要分为几个简单，数据初始化，dom 挂载，数据更新，组件卸载，在一个就是开启了组件缓存的时候，会有组件启用和组件停用阶段，每个阶段都去前后两个钩子除了缓存的那俩<br>数据初始化阶段<br>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。<br>created：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。<br>dom 挂载阶段<br>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。<br>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。<br>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted<br>数据跟新阶段<br>beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。<br>updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操 作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br>updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated：<br>缓存启用的时候会有下面两个钩子<br>activated：keep-alive 组件激活时调用。<br>deactivated：keep-alive 组件停用时调用。<br>组件卸载的时候：<br>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<h3 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h3><p>vue 实现数据双向绑定主要是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体话其实就是通过 Obeject.defineProperty() 中的 setter 和 getter 来监听属性变动实现 Observer 进行数据的监听然后就是通知订阅者，那么订阅者其实就是简单的一个数组，这个数组中的内容就是我门使用了的一个数据的集合，使用了的数据可以通过 getter 得到，其实就是在调用的时候给数组里面添加一个订阅者这样就是实现了一个 Watcher（需要监听的数据的集合），然后在实现一个 Compile 其作用就是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，其实 vue 的数据双向绑定就是 MVVM 作为数<br>据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>
<h3 id="Vue路由实现原理"><a href="#Vue路由实现原理" class="headerlink" title="Vue路由实现原理"></a>Vue路由实现原理</h3><p>在 vue 中路由主要有 hash 与 History interface 两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式：hash 和 Historyinterface，这两种模式的实现分别是<br>先说 hash，在浏览器的 url 中 hash（“#”）符号的本来作用是加在 URL 中指示网页中的位置：#符号本身以及它后面的字符称之为 hash，可通过<br>window.location.hash 属性读取。它具几个特点就是：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面，并且可以为 hash 的改变添加 hashchange 监听事件，在一个就是每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个 hash 模式的单页路由，通过对 location.hash 的修改实现 push 方法（跳转页面），通过对location.href 的修改实现 replace()方法，通过对 hashchange 事件的监听实现页面<br>跳转后的数据更新<br>而 History 模式则是完全采用了 h5 的新特性，从 HTML5 开始，History interface 提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及 popState 事件可以监听到状态的变更 不过 history 模式有一个问题就是 对于单页应用来讲，理想的使用场景是仅在进应用时加载 index.html，后续在的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候 history 模式则会将 URL 修改得就和正常请求后端的 URL 一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回 404 错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向 index.html 文件</p>
<h3 id="Vue组件通讯"><a href="#Vue组件通讯" class="headerlink" title="Vue组件通讯"></a>Vue组件通讯</h3><p>1.父组件传子组件<br>单项数据流 props<br>使用 refs 访问子组件<br>使用$parent 访问父组件<br>使用$children 访问子组件<br>使用$root 访问当前组件树的根 Vue 实例<br>在 template 元素使用 scope 可以访问到子组件中 slot 元素的属性值 要 13k<br>2.子组件传递数据给父组件：<br>子组件通过事件给父组件传数据，子组件通过$emit（eventName）触发事件，父 组件通过$on 监听事件<br>3.兄弟组件间通信<br>①用事件发布订阅 var bus=new vue（）；bus.$emit(“id-selected”,1)；bus.$on （”id-selected”,function(id){}）<br>②用 vuex 来实现</p>
<h3 id="Vuex的作用"><a href="#Vuex的作用" class="headerlink" title="Vuex的作用"></a>Vuex的作用</h3><p>Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存 储与操作，保证了所有状态以可预测的方式进行修改；<br>state: state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状<br>态。<br>actions:Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获<br>取数据，在数据获取完成后会调用 store.commit()来调用更改 Store 中的状态。可以 在组件中使用 dispatch 来发出 Actions。<br>mutations: 调用 mutations 是唯一允许更新应用状态的地方。<br>getters: Getters 允许组件从 Store 中获取数据，譬如我们可以从 Store 中的<br>projectList 中筛选出已完成的项目列表<br>modules: modules 对象允许将单一的 Store 拆分为多个 Store 的同时保存在 单一的状态树中。随着应用复杂度的增加，这种拆分能够更好地组织代码<br>但是 vuex 也有缺点就是，vuex 中保存的数据是和网页的生命周期同步的，当执行页面刷新的时候 vuex 中所有数据都会消失复位到初始状态，所以不太适合做有分享页面的数据交互（在这种项目中 vuex 只适合数据的集中管理，不适合数据的存储，这 种情况一般是使用路由传递参数会好一些），适合后台管理系统多一些，后台管理系统一般都是公司内部使用；</p>
<h3 id="Vue的优缺点"><a href="#Vue的优缺点" class="headerlink" title="Vue的优缺点"></a>Vue的优缺点</h3><p>优点：<br>简单：官方文档很清晰，比 Angular 简单易学。<br>快速：异步批处理方式更新 DOM。组合：用解耦的、可复用的组件组合你的应用程序。<br>紧凑：~18kb min+gzip，且无依赖。<br>强大：表达式 &amp; 无需声明依赖的可推导属性 (computed properties)。<br>对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循Angular 的各种规定，使用场景更加灵活。<br>vue 作者是中国人。由玉溪<br>缺点：<br>不兼容ie8，不过总体上觉得vue对我来说还是非常不错的，能看的懂文档，能上的去<br>手，开发模式也比较好</p>
<h3 id="对MVVM的理解"><a href="#对MVVM的理解" class="headerlink" title="对MVVM的理解"></a>对MVVM的理解</h3><p>MVVM 分为 Model、View、ViewModel 三者。<br>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；<br>View 代表 UI 视图，负责数据的展示；<br>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数<br>据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据<br>也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己<br>操作 dom。</p>
<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>当一个 Vue 实例创建时，vue 会遍历 data 选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h3 id="Vue如何监控属性值的变化"><a href="#Vue如何监控属性值的变化" class="headerlink" title="Vue如何监控属性值的变化"></a>Vue如何监控属性值的变化</h3><p>比如现在需要监控 data 中，obj.a 的变化。Vue 中监控对象属性的变化你可以这样：<br>watch: {<br>obj: {<br>handler (newValue, oldValue) {<br>console.log(‘obj changed’)<br>},<br>deep: true<br>}<br>}<br>deep 属性表示深层遍历，但是这么写会监控 obj 的所有属性变化，并不是我们想要的效果，所以做点修改：<br>watch: {<br>‘obj.a’: {<br>handler (newName, oldName) {<br>console.log(‘obj.a changed’)<br>}<br>}<br>}<br>还有一种方法，可以通过 computed 来实现，只需要：<br>computed: {<br>a1re(t)ur{n this.obj.a<br>}<br>}<br>利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。</p>
<h3 id="优化spa应用首屏加载速度"><a href="#优化spa应用首屏加载速度" class="headerlink" title="优化spa应用首屏加载速度"></a>优化spa应用首屏加载速度</h3><p> 将公用的 JS 库通过 script 标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度；<br> 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的 js 文件；加一个首屏 loading 图，提升用户体验；</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>我们使用 npm 或者 yarn 来安装 webpack，可以作为一<br>npm install webpack webpack-cli -g</p>
<p>或者</p>
<p>yarn global add webpack webpack-cli</p>
<p>然后就可以全局执行命令了</p>
<p>webpack –help<br>webpack-cli 是使用 webpack 的命令行工具，在 4.x<br>赖了，我们使用时需要单独安装这个工具<br>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模<br>块的代码打包：</p>
<h3 id="提升webpack的构建速度"><a href="#提升webpack的构建速度" class="headerlink" title="提升webpack的构建速度"></a>提升webpack的构建速度</h3><p>1.<br>减少 resolve 的解析<br>使用绝对路径指定 node_modules，不做过多查询<br>删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路<br>径查询的工作<br>避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也<br>有益于提高构建速度<br>2.<br>把 loader 应用的文件范围缩小<br>我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只<br>在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目<br>录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过<br>loader 处理了<br>3. 减少 plugin 的消耗<br>webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的<br>话，适当地移除掉一些没有必要的 plugin。</p>
<h3 id="Webpack工作流程"><a href="#Webpack工作流程" class="headerlink" title="Webpack工作流程"></a>Webpack工作流程</h3><p>webpack 本质上就是一个 JS Module Bundler，用于将多个代码模块进行打包<br>JS Module Bunlder 的基础工作流程：</p>
<ol>
<li>首先，bundler 从一个构建入口出发，解析代码，分析出代码模块依赖关系，然后将<br>依赖的代码模块组合在一起，在 JavaScript bundler 中，还需要提供一些胶水代码<br>让多个代码模块可以协同工作，相互引用。</li>
</ol>
<p>2.<br>首先是解析代码，分析依赖关系：根据入口解析出依赖代码文件，继续解析其依赖，<br>递归下去，直至没有更多的依赖模块，最终形成一颗模块依赖树。<br>3.<br>分析出依赖关系后，bunlder 需要将依赖关系中涉及的所有文件组合到一起，但由于<br>依赖代码的执行是有先后顺序以及会引用模块内部不同的内容，不能简单地将代码拼<br>接到一起。webpack 会利用 JavaScript Function 的特性提供一些代码来将各个模<br>块整合到一起，即是将每一个模块包装成一个 JS Function，提供一个引用依赖模块<br>的方法<br>webpack 工作的主要流程和其中几个重要的概念</p>
<ol>
<li>Compiler，webpack 的运行入口，实例化时定义 webpack 构建主要流程，同时创建 构建时使用的核心对象 compilation</li>
<li>Compilation，由 Compiler 实例化，存储构建过程中各流程使用到的数据，用于控<br>制这些数据的变化</li>
<li>Chunk，即用于表示 chunk 的类，对于构建时需要的 chunk 对象由 Compilation 创 建后保存管理</li>
<li>Module，用于表示代码模块的类，衍生出很多子类用于处理不同的情况，关于代码模 块的所有信息都会存在 Module 实例中，例如 dependencies 记录代码模块的依赖等</li>
<li>Parser，其中相对复杂的一个部分，基于 acorn 来分析 AST 语法树，解析出代码模 块的依赖</li>
<li>Dependency，解析时用于保存代码模块对应的依赖使用的对象</li>
<li>Template，生成最终代码要使用到的代码模板，像上述提到的胶水代码就是用对应的Template 来生成<br>webpack 运行的大概工作流程是这样的：<br>创建 Compiler -&gt;<br>调用 compiler.run 开始构建 -&gt;<br>创建 Compilation -&gt;<br>基于配置开始创建 Chunk -&gt;<br>使用 Parser 从 Chunk 开始解析依赖 -&gt;<br>使用 Module 和 Dependency 管理代码模块相互关系 -&gt;<br>使用 Template 基于 Compilation 的数据生成结果代码<br>参考： <a target="_blank" rel="noopener" href="https://github.com/DDFE/DDFE-blog/issues/12">https://github.com/DDFE/DDFE-blog/issues/12</a></li>
</ol>
<h3 id="webpack基本配置"><a href="#webpack基本配置" class="headerlink" title="webpack基本配置"></a>webpack基本配置</h3><p>Entry 配置模块的入口；<br>Output 配置如何输出最终想要的代码；<br>Module 配置处理模块的规则；<br>Resolve 配置寻找模块的规则；<br>Plugins 配置扩展插件；<br>DevServer 配置 DevServer；</p>
<h3 id="Webpack生产和开发环境的区别"><a href="#Webpack生产和开发环境的区别" class="headerlink" title="Webpack生产和开发环境的区别"></a>Webpack生产和开发环境的区别</h3><p>日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于 本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件；另外一套 构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap 的。有的时候可能还需要多一套测试环境，在运行时直接 进行请求 mock 等工作。<br>webpack 4.x版本在webpack配置中有mode选项可以直接配置production 或 development webpack 3.x 一般是通过node命令传递环境变量，来控制不同环境下的构建行为 如：<br>{<br>“scripts”: {<br>“build”: “NODE_ENV=production webpack”,<br>“dev”: “NODE_ENV=development webpack-dev-server”<br>}<br>}<br>然后在 webpack.config.js 文件中可以通过 process.env.NODE_ENV 来获取命令传入的环境变量：<br>常见的环境差异配置<br>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件<br>生产环境需要压缩 HTML/CSS/JS 代码<br>生产环境需要压缩图片<br>开发环境需要生成 sourcemap 文件<br>开发环境需要打印 debug 信息<br>开发环境需要 live reload 或者 hot reload 的功能<br>以上是常见的构建环境需求差异，可能更加复杂的项目中会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。<br>webpack 4.x 的 mode 已经提供了上述差异配置的大部分功能，mode 为 production 时默认使用 JS 代码压缩，而 mode 为 development 时默认启用 hot reload，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 loader 和 plugin 做区分配置就可以了。<br>webpack 3.x 版本还是只能自己动手修改配置来满足大部分环境差异需求。</p>
<h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p>什么是跨域？<br>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。<br>什么是同源策略？<br>同源策略是一种约定(只存在于客户端(浏览器))，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。<br>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。<br>同源策略限制以下几种行为：<br>1.Cookie、LocalStorage 和 IndexDB 无法读取<br>2.DOM 和 Js 对象无法获得<br>3.AJAX 请求不能发送<br>跨域解决方案<br>1、cors (跨域资源共享)<br>2、jsonp<br>3、iframe<br>4、nginx 代理跨域<br>5、nodejs 中间件代理跨域<br>6、WebSocket 协议跨域</p>
<h3 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h3><p>W3C<br>W3C 是 World Wide Web Consortium 的缩写，表示的是“万维网联盟”。<br>W3C 是 WEB 技术领域，国际中立性技术标准机构。主要工作是发展 WEB 规范。<br>SPA<br>单页 Web 应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动 态更新该页面的 Web 应用程序。<br>特点<br>速度：更好的用户体验，让用户在 web app 感受 native app 的速度和流畅，<br>MVC：经典 MVC 开发模式，前后端各负其责。<br>ajax：重前端，业务逻辑全部在本地操作，数据都需要通过 AJAX 同步、提交。<br>路由：在 URL 中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。<br>单页 Web 应用（single page web application，SPA）是当今网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页 Web 应用，新的 单页 Web 应用网站（包括移动平台上的）也如雨后春笋般涌现在人们的面前，如 Gmail、Evernote、Trello 等。如果你是一名 Web 开发人员， 却还没开发过或者甚至是没有听说过单页应用，那你已经 Out 很久了。<br>单页 Web 应用和前端工程师们息息相关，因为主要的变革发生在浏览器端，用到的技术其实还是 HTML+CSS+JavaScript，所有的浏览器都原生 支持，当然有的浏览器因为具备一些高级特性，从而使得单页 Web 应用的用户体验更上一层楼。关于单页应用的优点和缺点，网上讲解的文章有 很多，这里就不展开论述了。 单页 Web 应用，顾名思义，就是只有一张 Web 页面的应用。浏览器一开始会加载必需的 HTML、CSS 和<br>JavaScript，之后所有的操作都在这张页面上完成，这一切都由 JavaScript 来控制。因此，单页 Web 应用会包含大量的 JavaScript 代码，复杂度 可想而知，模块化开发和设计的重要性不言而喻<br>CDN<br>简单地说，CDN 是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理 4 个要件，而内容管理和全局的网<br>络流量管理(Traffic Management)是 CDN 的核心所在。通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请<br>求提供服务。<br>解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet 网络拥挤 的状况，提高用户访问网站的响应速度和成功率。<br>控制时延无疑是现代信息科技的重要指标，CDN 的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。<br>CDN 就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。 再通俗点说就是在网速一定的前提下，CDN 就像网络中快递员小哥<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37353035/answer/175217812">https://www.zhihu.com/question/37353035/answer/175217812</a><br>Hack<br>Hack，英文含义为“修改”。由于不同的浏览器对 CSS 的支持程度不同，同样 CSS 的样式代码在不同浏览器当中的表现可能出现不一致。为了让 所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。<br>Hack 技术的原理<br>利用 CSS 中的优先级以及 CSS Hack 技术，来实现“不同浏览器”对应“不同 CSS”的需求。<br>Hack 的种类<br>CSS Hack 主要针对 IE 浏览器，可以分为 3 种表现形式：<br>● 属性前缀法：CSS 属性上添加 Hack（<br>eight: 300px;）；<br>● 选择器前缀法：在选择器上添加 Hack（<br>tml { }）；<br>● 条件注释法：头部引用 Hack（&lt;!–[if lt IE 8]–&gt;）。<br>GPU&amp;CPU<br>显卡的处理器称为图形处理器（GPU），它是显卡的“心脏”，与 CPU 类似，只不过 GPU 是专为执行复杂的数学和几何计算而设计的。<br>默认情况下，网页的渲染使用的是 CPU。如果有了 GPU 来处理图形任务，那么 CPU 就可以执行其他更多系统任务，从而提升计算机整体性能。<br>GPU 加速的主要用途<br>主要用于 CSS3 技术中，提升二维动画的渲染速度。<br>GPU 加速的触发方法<br>为动画 DOM 元素添加如下 CSS3 样式。<br>-webkit-transform:transition3d(0,0,0)；<br>-webkit-transform:translateZ(0);<br>两种方法都会开启 GPU 硬件加速模式，从而让浏览器在渲染动画时从 CPU 转向 GPU。<br>对于网页效果来说，由于如上代码中的值设置为 0，因此，并没有真正使用 3D 效果，但浏览器却因此开启了 GPU 硬件加速模式。<br>GPU 加速的应用场景<br>● 涉及大量大尺寸图片的动画；<br>● 涉及大量 DOM 元素的 CSS3 动画。<br>Sprite<br>CSS Sprite，也有人将其称为 CSS 精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都合并到一张大图当中，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。<br>CSS Sprite 的原理<br>CSS Sprite 与 Photoshop 的背景图合并一样，就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的 background-position 属性的进行背景定位。<br>缺点：<br>png 图片本身大小会超过 jpg，解决办法，尽量吧小的图片转成 baseurl， 在吧精灵图压缩<br>UA<br>UA 是 User Agent 的缩写。<br>UA 是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。<br>UA 的用途<br>例如：检测当前访问设备的类型（移动设备还是桌端设备），并根据具体情况实现“重定向”。<br>ERP：<br>(企业资源计划——Enterprise Resource Planning)<br>ERP 是针对物资资源管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体化的企业管理软件。ERP<br>的核心管理思想就是实现对整个供应链的有效管理<br>OA：<br>(办公自动化——Office Automation)<br>是现代利用电脑进行全自动的办公，目的是提高效率。<br>CMS<br>内容管理系统——Content Management System<br>它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。CMS 其实是一个很广泛的称呼，从一般的博客程序，新闻发布程<br>序，到综合性的网站管理程序都可以被称为内容管理系统。<br>CRM：<br>“客户关系管理(CRM)是代表增进赢利、收入和客户满意度而设计的，企业范围的商业战略。” ：”客户关系管理(CRM)是代表增进<br>主要是管理客户和供应商，以及管理仓库和物料，其主要表现在客户资料管理、联系记录的管理和订单的管理等，多用于业务部门。如：记录客户<br>的联系方式，客户的需求，客户的交易记录等和客户相关的功能。但是不具有 ERP 的预警、分析等职能。CRM 不是企业级管理系统，一般只应用于销售部。<br>GIS:<br>地理信息系统（Geographic Information System 或 Geo－Information system，GIS）有时又称为“地学信息系统”。一般来说是和地图应用<br>相关的项目<br>IaaS:<br>Infrastructure-as-a-Service(基础设施即服务)有了 IaaS，你可以将硬件外包到别的地方去。IaaS 公司会提供场外服务器，存储和网络硬件，你可 以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的 IaaS 公司包括 Amazon, Microsoft, VMWare, Rackspace 和 Red Hat.不过这些公司又都有自己的专长，比如 Amazon 和微软给你提供的不只是 IaaS，他们还会将其计算能力出租给你来 host 你的网站。<br>PaaS:<br>Platform-as-a-Service(平台即服务)第二层就是所谓的 PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资 源。PaaS 公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的 合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的 PaaS 提供者有 Google App<br>Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有 AppFog,Mendix 和 Standing Cloud.<br>SaaS:<br>Software-as-a-Service(软件即服务)第三层也就是所谓。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务 器上的应用都可以通过网络来运行，就是 SaaS 了。你消费的服务完全是从网页如 Netflix,MOG,Google Apps,Box.net,Dropbox 或者苹果的<br>iCloud 那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。一些用作商务的 SaaS 应用包括<br>Citrix 的 Go To Meeting，Cisco 的 WebEx，Salesforce 的 CRM，ADP，Workday 和 SuccessFactors。</p>
<h3 id="Node面试题"><a href="#Node面试题" class="headerlink" title="Node面试题"></a>Node面试题</h3><p>1.为什么要用 node?<br>参考答案: 总结起来 node 有以下几个特点:简单强大，轻量可扩展．简单体现在 node 使用的是 javascript,json 来进行编码，人人都会；强大体现在非阻塞 IO,可以适应分 块传输数据，较慢的网络环境，尤其擅长高并发访问；轻量体现在 node 本身既是代 码，又是服务器，前后端使用统一语言;可扩展体现在可以轻松应对多实例，多服务器 架构，同时有海量的第三方应用组件．<br>2.node 的构架是什么样子的?<br>参考答案: 主要分为三层，应用 app &gt;&gt; V8 及 node 内置架构 &gt;&gt; 操作系统. V8 是 node 运行的环境，可以理解为 node 虚拟机．node 内置架构又可分为三层: 核心模 块(javascript 实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http.<br>3.node 有哪些核心模块?<br>参考答案: EventEmitter, Stream, FS, Net 和全局对象<br>node 全局对象<br>1.node 有哪些全局对象?<br>参考答案: process, console, Buffer 和 exports<br>2.process 有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env,<br>process.argv, process.arch, process.platform, process.exit<br>3.console 有哪些常用方法?<br>参考答案: console.log/console.info, console.error/console.warning,<br>console.time/console.timeEnd, console.trace, console.table<br>4.node 有哪些定时功能?<br>参考答案: setTimeout/clearTimeout, setInterval/clearInterval,<br>setImmediate/clearImmediate, process.nextTick<br>node 中的事件循环是什么样子的?<br>总体上执行顺序是：process.nextTick &gt;&gt; setImmidate &gt;&gt;<br>setTimeout/SetInterval 看官网吧：<br><a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/master/doc/topics/event-loop-timers-and-nexttick.md">https://github.com/nodejs/node/blob/master/doc/topics/event-loop-timers-and-nexttick.md</a><br>node 中的 Buffer 如何应用?<br>参考答案: Buffer 是用来处理二进制数据的，比如图片，mp3,数据库文件等.Buffer 支持各种编码解码，二进制字符串互转．</p>
<h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>1.内置的 fs 模块架构是什么样子的?<br>参考答案: fs 模块主要由下面几部分组成: 1) POSIX 文件 Wrapper,对应于操作系统的 原生文件操作 2) 文件流 fs.createReadStream 和 fs.createWriteStream 3) 同步文<br>件读写,fs.readFileSync 和 fs.writeFileSync 4) 异步文件读写, fs.readFile 和 fs.writeFile<br>2.读写一个文件有多少种方法?<br>参考答案: 总体来说有四种: 1) POSIX 式低层读写 2) 流式读写 3) 同步文件读写 4) 异步文件读写<br>3.怎么读取 json 配置文件?<br>参考答案: 主要有两种方式，第一种是利用 node 内置的 require(‘data.json’)机制，直接得到 js 对象; 第二种是读入文件入内容，然后用 JSON.parse(content)转换成 js对象．二者的区别是 require 机制情况下，如果多个模块都加载了同一个 json 文件，那么其中一个改变了 js 对象，其它跟着改变，这是由 node 模块的缓存机制造成的，只有一个 js 模块对象; 第二种方式则可以随意改变加载后的 js 变量，而且各模块互不影响，因为他们都是独立的，是多个 js 对象.<br>4.fs.watch 和 fs.watchFile 有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch 利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile 则是定期检查文件状态变更，适用于网络文件系统，但是相比 fs.watch 有些慢，因为不是实时机制．</p>
<h3 id="Set和map-数据结构"><a href="#Set和map-数据结构" class="headerlink" title="Set和map 数据结构"></a>Set和map 数据结构</h3><p>1、set<br>基本用法：<br>（1）类似于数组，但是成员的值都是唯一的，没有重复的值。<br>(2) Set 结构不会添加重复的值<br>(3) 可以接受一个数组（或类似数组的对象（arguments））作为参数，用来初始化，其 他类型报错<br>(4)扩展运算符…可以将其变成一个数组；<br>(5) 向 Set 加入值的时候，不会发生类型转换; 内部判断两个值是否不同,类似于精确相等运算符（===），主要的区别是 NaN 等于自身<br>(6) 两个对象总是不相等的；内存地址不一样；<br>(7) Array.from 方法可以将 Set 结构转为数组。<br>Set 实例的属性和方法：<br>(1) 四个操作方法：<br> add(value)：添加某个值，返回 Set 结构本身。<br> delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br> has(value)：返回一个布尔值，表示该值是否为 Set 的成员。<br> clear()：清除所有成员，没有返回值。<br>(2)遍历方法：<br> keys()：返回键名的遍历器（无键名，此方法和 values（）类似）<br> values()：返回键值的遍历器<br> entries()：返回键值对的遍历器<br> forEach()：使用回调函数遍历每个成员，处理函数参数依次为键值、键<br>名、集合本身；第二个参数，表示绑定的 this 对象。<br> 注：Set 的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set<br>保存一个回调函数列表，调用时就能保证按照添加顺序调用<br> 扩展运算符和 Set 结构相结合，数组的 map 和 filter 方法也可以用于 Set<br>了很容易地实现并集（Union）、交集（<br>Intersect）和差集；<br> 同步改变原来的 Set 结构，一种是利用原 Set 结构映射出一个新的结构，<br>然后赋值给原来的 Set 结构；另一种是利用 Array.from 方法<br>3、Map<br>含义：类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型<br>的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的<br>对应，Map 结构提供了“值—值”的对应用法：<br>(1) 任何具有 Iterator 接口的数据结构都可以作为参数；<br>(2) 对同一个键多次赋值，后面的值将覆盖前面的值。<br>(3) 读取一个未知的键，则返回 undefined。<br>(4) 设置和读取一个键，必须是同一个内存地址，才可以读取成功；ap 的键实<br>际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键<br>(5) 果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个<br>值严格相等，Map 将其视为一个键，包括 0 和-0，布尔值 true 和字符串<br>true 则是两个不同的键。另外，undefined 和 null 也是两个不同的键。虽<br>然 NaN 不严格相等于自身，但 Map 将其视为同一个键。<br>(6) 接受参数必须为数组，set、map、以及具有 Iterator 接口的任何数据；<br>属性：size 返回 map 的总成员；<br>方法：<br>(1)set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如<br>果 key 已经有值，则键值会被更新，否则就新生成该键。<br>(2)get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。<br>(3)has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br>(4)delete 方法删除某个键，返回 true。如果删除失败，返回 false。<br>(5)clear 方法清除所有成员，没有返回值。<br>(6)默认遍历器接口（<br>Symbol.iterator 属性），就是 entries 方法。<br>(7)转为数组结构，比较快速的方法是使用扩展运算符（…）结合数组的 map<br>方法、filter 方法，可以实现 Map 的遍历和过滤（Map 本身没有 map<br>和 filter 方法）。<br>遍历方法：（原生的）<br> keys()：返回键名的遍历器。<br> values()：返回键值的遍历器。<br> entries()：返回所有成员的遍历器。<br> forEach()：遍历 Map 的所有成员。与数组的 forEach 类似，第<br>二个参数用来绑定 this；<br>与其他数据结构的相互转换：<br>（1） Map 转为数组：使用扩展运算符（…）、Array.from()<br>（2） 数组 转为 Map<br>（3） 如果所有 Map 的键都是字符串，它可以转为对象。自定义方法进行<br>转换，借助 for of<br>（4） 对象转为 Map 借助 for of<br>（5） Map 转为 JSON<br>（6） JSON 转为 Map</p>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。<br>Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束</p>
<h3 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h3><p>重新创建</p>
<p>首先要明白四个空间：远程仓库，本地仓库，本地缓存区，本地工作区</p>
<p>远程仓库</p>
<p>该仓库是一个集中的数据仓库，正常情况下，所有参与开发的人员的代码最后都会提交到该仓库的自己的分支上，再由具有合并权限的人员来合并所有分支；<br> ####本地仓库：<br>一般来说，本地仓库是由开发人员通过 clone 复制远程仓库中的某个分支的数<br>据到本地而产生的，但 git 不是集中式的版本控制，而是分布式的版本控制，他们的区别就是，分布式版本控制中每一个仓库都能具有远程仓库的作用，而集中式的版本控制中远程仓库是不能被其他参与开发的人备份的；</p>
<p>本地缓存</p>
<p>在本地修改数据后（一般是指我们在编辑器中修改某个文件），git 监测到该数<br>据与本地数据仓库的数据不一致，会提示将该修改增加add）到缓存区，缓存区中的文件可以用来与本地仓库中的文件进行比较（difftool），这个用处目前感觉主要用于当我们修改很多文件时，最后不记得自己修改了那些文件，如果没有缓存区，我们直接提交的话，很容易会导致很多疏忽。我们在编辑器中修改了文件后（本地工作区），本地缓存中不包含我们的修改的，只有当我们把本次的修改 add 到缓存区的时候，缓存区中才有本次的修改，这表明我们的每一次修改都必须手动 add 到本地缓存中才能在使用 commit 命令时将其添加到本地仓库。</p>
<p>本地工作区</p>
<p>也就是我们的编辑器的空间；</p>
<p>分支命名规则</p>
<p>1.主分支：master<br>2.CICD： autoDeploy<br>3.开发分支：develop<br>4.功能分支：feature-分支名称/功能名称 (例： git checkout -b feature-autoMLlist)<br>5.分支发布：release-日期<br>6.bug 分支修复：bugfix-日期</p>
<p>分支开发节点</p>
<p>鉴于此后在代码管理流程上，需按严格要求执行，所以在每日开发的功能或者<br>bug 必须于当日完成以及提交 pull request,便于代码 review。</p>
<p>开发流程</p>
<p>在 develop 分支，多人需要开发不同的功能，这里就会用到 feature 分支。团队中的每个人都从 Github 克隆一个项目，然后新建自己的 feature 分支。</p>
<p>git clone xxxx.git<br>git checkout develop<br>git checkout -b feature-×× develop # 从 develop 分支新建并检出 feature分支）</p>
<p>这里可以进行一些功能开发，并不断的 add 和 commit</p>
<p>git checkout develop # 切换回 develop 分支<br>git pull origin develop # 更新远端代码，看 develop 分支是否有更新（无更新）<br>git checkout feature-×× # 切换回 feature 分支<br>git rebase develop # 合并 develop 分支到 feature 分支，并解决冲突（无冲突）<br>git checkout develop # 切换回 develop 分支<br>git merge –no-ff feature-hu # 合并 feature 分支到 develop 分支<br>git push origin develop # 推送 develop 分支到远端</p>
<p>下面遇到冲突解决</p>
<p>对于团队其他成员开发，操作如下，并打算在上面提交后进行 push 操作</p>
<p>git checkout -b feature-zz develop # 从 develop 分支新建并检出 feature 分支</p>
<p>这里可以进行一些功能开发，并不断的 add 和 commit</p>
<p>git checkout develop # 切换回 develop 分支<br>git pull origin develop # 更新远端代码，看 develop 分支是否有更新（有更新）<br>git checkout feature-×× # 切换回 feature 分支<br>git rebase develop # 合并 develop 分支到 feature 分支，并解决冲突（有冲突）</p>
<p>这里需要进行冲突解决</p>
<p>git add . # 解决完冲突之后执行 add 操作<br>git rebase –continue # 继续刚才的 rebase 操作<br>git checkout develop # 切换回 develop 分支<br>git merge –no-ff feature-×× # 合并 feature 分支到 develop 分支（无冲突）<br>git push origin develop # 推送 develop 分支到远端</p>
<p>git merge 与 git rebase 区别 对于使用 git merge 来合并所看到的 commit 的顺序（从新到旧）–&gt; 根据提交的时间顺序排列下来</p>
<p>于使用 git rebase 来合并所看到的 commit 的顺序（从新到旧） –&gt; 合并之后主分支会重新克隆被合并的分支提交信息并到主分支上</p>
<p>git stash 暂存代码</p>
<p>过 git stash save ‘message’这条命令把未保存的修改的代码提交到本地暂开的仓库<br>过 git stash pop stash@{0} 可以恢复之前被暂存的代码<br>it stash list 可以查看现有的所有 stash 信息<br>it stash drop 可以删除某个或全部 stash 信息 单个为直接后面跟信息名称<br>执行命令可以使得在开发人员未开发完成此次功能时，需介入其他分支开发， 所有可以使用这些命令管理这些未完成代码</p>
<p> 回退版本</p>
<p>it reset –hard HEAD^ 可以回退到上一个版本，也可以直接跟每一个的版本信息直接跳到该版本信息下（查看版本信息是 git log）<br>果在回退回去之后后悔，也可以再返回，但需要知道版本号（版本 ID），通过 git reflog 查到每一个版本信息 ID， 输入然后跳转<br>it diff 可以列举出本次提交修改过的代码</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://iamwangzhaoyu.github.io/2022/06/25/Interview-questions/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/06/25/hello-world/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hello World</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> wangzhaoyu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/header.png" alt="我的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/src/Interview">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/src/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/src/my">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>